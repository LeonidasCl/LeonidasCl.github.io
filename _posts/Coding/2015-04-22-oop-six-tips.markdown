---
layout: post
title:  "面向对象六大原则"
date:   2016-04-22 22:14:54
categories: Coding
comments: true
---

1.单一职责原则
----------------
单一实现类只负责单一的工作。
例如，在图片加载器中，有特定的类负责从网络异步下载，有特定的类负责缓存，不同的功能在不同的类之间实现，避免了代码冗余，也便于修改。
在图片框架的各实现类中，`ImgTaskManager`只负责发起异步任务

![图片1](20160422p1.jpg)

缓存到SD卡的任务，写在类`SDimageCache`中，`ImgTaskManager`持有一个该类的引用，去执行本地缓存的任务。

![`图片2`](20160422p2.jpg "图片2")

2.开闭原则
-----------------
类的实现对修改关闭，对拓展开启。
`ImgTaskManager`的`loadImg`方法提供一个异步加载图片的API

![图片8](20160422p8.jpg "图片8")

其中，model是一个图片对象，在这个类中的src是图片资源，通常情况下，框架会自动根据url加载图片，但用户可能需要自己的图片加载方式。
于是，为了不修改PictureModel类的源代码，预留了src的set方法，这样在用户在使用该类时可自己添加一个加载图片资源的方式。

![`图片3`](20160422p3.jpg "图片3")

这样写，就是依赖注入的方式，自定义PictureModel中图片源文件的获取方式。

![`图片4`](20160422p4.jpg "图片4")

自定义的方式算是对原有实现的拓展，而没有修改原有代码，这就是面向对象编程中对修改封闭，对拓展开启的原则。

3.里氏替换原则
----------------
这个原则的定义十分复杂，但总结起来就是一个核心思想——抽象。
即子类可以在父类被引用的地方替代父类。
例如，基类A提供了方法methodA，继承该类的B和C重写methodA后，A的引用如果实际上是B类对象，调用methodA时会调用B的methodA方法，起到“替换”的效果。
在CacheInterface中设置了get方法，并在不同种类缓存中给了不同实现.
PictureModel中获取drawable直接用get：

![`图片5`](20160422p5.jpg "图片5")

4.依赖倒置原则
---------------
1.高层模块不依赖于低层模块，两者都依赖于抽象。
2.抽象不依赖于细节，细节依赖于抽象。
实现不能相互依赖，都依赖于抽象，如果实现类之间有依赖关系，那么它们的依赖应该在抽象时写好：

![`图片6`](20160422p6.jpg "图片6")

5.接口分离原则
-------------------
为避免实现类代码冗余，复杂的接口应当尽量分离成简单的接口，这样用户不需要了解它们不需要用到的方法。个人的理解是，由于面向对象编程要求类的职责单一，所以实现类相应的抽
象（或接口）也应当适当的对职责进行分离，这样才能确保实现细节时有清晰的思路，知道该往哪些方法里填代码。

6.迪米特原则
----------------
迪米特原则的定义是“一个对象应该对其他对象有最少的了解”。这句话应当是在描述类之间耦合的程度——一个类应当对自己要关联、调用的类知道得最少，即耦合要低。遵循迪米特原则的
类可以更好的支持修改和拓展，相互之间的依赖关系也不至于混乱。例如下图：

![`图片7`](20160422p7.jpg "图片7")
